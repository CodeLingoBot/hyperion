// Code generated by mockery v1.0.0. DO NOT EDIT.

// NOTE: run 'make update-mocks' to regenerate

package light

import context "context"
import mock "github.com/stretchr/testify/mock"

// MockManager is an autogenerated mock type for the Manager type
type MockManager struct {
	mock.Mock
}

// GetAllStates provides a mock function with given fields:
func (_m *MockManager) GetAllStates() *StateMap {
	ret := _m.Called()

	var r0 *StateMap
	if rf, ok := ret.Get(0).(func() *StateMap); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StateMap)
		}
	}

	return r0
}

// GetByName provides a mock function with given fields: name
func (_m *MockManager) GetByName(name string) Light {
	ret := _m.Called(name)

	var r0 Light
	if rf, ok := ret.Get(0).(func(string) Light); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Light)
		}
	}

	return r0
}

// GetDMXState provides a mock function with given fields:
func (_m *MockManager) GetDMXState() *DMXState {
	ret := _m.Called()

	var r0 *DMXState
	if rf, ok := ret.Get(0).(func() *DMXState); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DMXState)
		}
	}

	return r0
}

// GetDiscoveredHues provides a mock function with given fields:
func (_m *MockManager) GetDiscoveredHues() DiscoveredHues {
	ret := _m.Called()

	var r0 DiscoveredHues
	if rf, ok := ret.Get(0).(func() DiscoveredHues); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(DiscoveredHues)
	}

	return r0
}

// GetHueConnection provides a mock function with given fields:
func (_m *MockManager) GetHueConnection() HueConnection {
	ret := _m.Called()

	var r0 HueConnection
	if rf, ok := ret.Get(0).(func() HueConnection); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(HueConnection)
		}
	}

	return r0
}

// GetLightNames provides a mock function with given fields:
func (_m *MockManager) GetLightNames() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// GetLightsByName provides a mock function with given fields:
func (_m *MockManager) GetLightsByName() NameMap {
	ret := _m.Called()

	var r0 NameMap
	if rf, ok := ret.Get(0).(func() NameMap); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(NameMap)
		}
	}

	return r0
}

// GetState provides a mock function with given fields: name
func (_m *MockManager) GetState(name string) *State {
	ret := _m.Called(name)

	var r0 *State
	if rf, ok := ret.Get(0).(func(string) *State); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*State)
		}
	}

	return r0
}

// SetDMXState provides a mock function with given fields: ctx, ops
func (_m *MockManager) SetDMXState(ctx context.Context, ops ...dmxOperation) error {
	_va := make([]interface{}, len(ops))
	for _i := range ops {
		_va[_i] = ops[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...dmxOperation) error); ok {
		r0 = rf(ctx, ops...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetState provides a mock function with given fields: name, new
func (_m *MockManager) SetState(name string, new State) {
	_m.Called(name, new)
}
